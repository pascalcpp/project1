例题：寻找指定和的整数对
输入n ( n<= 100,000)个整数，找出其中的两个数，它们之和等于整数m(假定肯
定有解)。题中所有整数都能用 int 表示
解法1：用两重循环，枚举所有的取数方法，复杂度是O(n2
)的。
for(int i = 0;i < n-1; ++i)
for(int j = i + 1; j < n; ++j)
if( a[i]+a[j] == m)
break;
100,0002 = 100亿，在各种OJ上提交或参加各种程序设计竞赛，这样的复杂度都会超时





输入n ( n<= 100,000)个整数，找出其中的两个数，它们之和等于整数m(假定
肯定有解)。题中所有整数都能用 int 表示
解法2：
1) 将数组排序，复杂度是O(n×log(n))
2) 对数组中的每个元素a[i],在数组中二分查找m-a[i]，看能否找到。复杂度log(n)，最
坏要查找n-2次，所以查找这部分的复杂度也是O(n×log(n))
这种解法总的复杂度是O(n×log(n))的。



输入n ( n<= 100,000)个整数，找出其中的两个数，它们之和等于整数m(假定
肯定有解)。题中所有整数都能用 int 表示
解法3：
1) 将数组排序，复杂度是O(n×log(n))
2) 查找的时候，设置两个变量i和j,i初值是0,j初值是n-1.看a[i]+a[j],如果大于m，就让j
减1，如果小于m,就让i加1，直至a[i]+a[j]=m。
这种解法总的复杂度是O(n×log(n))的。




农夫 John 建造了一座很长的畜栏，它包括N (2≤N≤100,000)个隔间，这
些小隔间的位置为x0
,...,xN-1 (0≤xi≤1,000,000,000,均为整数,各不相同).
John的C (2≤C≤N)头牛每头分到一个隔间。牛都希望互相离得远点省得互
相打扰。怎样才能使任意两头牛之间的最小距离尽可能的大，这个最大的
最小距离是多少呢？

解法1：
先得到排序后的隔间坐标 x0,...,xN-1
从1,000,000,000/C到1依次尝试这个“最大的最近距离”D， 找到的
第一个可行的就是答案。
尝试方法：
1) 第1头牛放在x0
2) 若第k头牛放在xi ，则找到xi+1到xN-1中第一个位于[xi+D, 1,000,000,000]中的Xj
第k+1头牛放在Xj。找不到这样的Xj
,则 D=D-1,转 1)再试
若所有牛都能放下，则D即答案
复杂度 1,000,000,000/C *N，即 1,000,000,000, 超时!


解法2：
先得到排序后的隔间坐标 x0,...,xN-1
在[L,R]内用二分法尝试“最大最近距离”D = (L+R)/2 (L,R初值为
[1, 1,000,000,000/C]
若D可行，则记住该D，然后在新[L,R]中继续尝试(L= D+1)
若D不可行，则在新[L,R]中继续尝试(R= D-1)
复杂度 log(1,000,000,000/C) * N
